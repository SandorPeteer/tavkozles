<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <title>Testjel alapú Polaritás Mérő</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f7f7f7;
      text-align: center;
      margin: 20px;
    }
    h1 { color: #333; }
    .section {
      border: 1px solid #ccc;
      background: #eee;
      padding: 10px;
      margin: 10px;
    }
    button, select {
      font-size: 1rem;
      margin: 0.5rem;
      padding: 0.3rem 0.8rem;
    }
    #canvas {
      border: 1px solid #ccc;
      background: #fff;
      margin: 20px auto;
      display: block;
    }
  </style>
</head>
<body>
  <h1>Testjel alapú Polaritás Mérő</h1>
  <!-- Üzemmód választás -->
  <div>
    <label for="modeSelect">Üzemmód:</label>
    <select id="modeSelect">
      <option value="transmitter">Adó (Transmitter)</option>
      <option value="receiver">Vevő (Receiver)</option>
    </select>
  </div>
  
  <!-- Adó (Transmitter) rész -->
  <div id="transmitterSection" class="section">
    <h2>Adó (Transmitter)</h2>
    <label for="txPolaritySelect">Testjel polaritása:</label>
    <select id="txPolaritySelect">
      <option value="normal">Normál</option>
      <option value="inverted">Inverz</option>
    </select>
    <br>
    <button id="txStartBtn">Adó Start</button>
    <button id="txStopBtn">Adó Stop</button>
    <p id="txStatus">Adó: várakozás...</p>
  </div>
  
  <!-- Vevő (Receiver) rész -->
  <div id="receiverSection" class="section" style="display: none;">
    <h2>Vevő (Receiver)</h2>
    <button id="rxStartBtn">Vevő Start</button>
    <button id="rxStopBtn">Vevő Stop</button>
    <p id="rxResult">Eredmény: várakozás...</p>
  </div>
  
  <!-- Canvas: opcionális, a jel vizualizálásához -->
  <canvas id="canvas" width="800" height="200"></canvas>
  <p id="status">Állapot: várakozás...</p>
  
  <script>
    /********** Globális változók **********/
    let audioContext = null;
    let mode = "transmitter"; // alapértelmezett üzemmód
    const modeSelect = document.getElementById("modeSelect");
    const transmitterSection = document.getElementById("transmitterSection");
    const receiverSection = document.getElementById("receiverSection");
    const statusElem = document.getElementById("status");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    
    // Testjel paraméterek (Adó):
    const T_total = 1.5;   // a teljes testjel időtartama (s)
    const T_ramp = 0.2;    // felfutás idő (s)
    const T_hold = 0.8;    // hold rész idő (s); ebből:
                           // – első fele: 0.2–0.6 s: fázis +1
                           // – második fele: 0.6–1.0 s: fázis -1
    const T_fade = 0.5;    // lecsengés idő (s)
    const fc = 500;        // carrier frekvencia (Hz)
    // A testjelet ismételjük, például 2 s periódusban
    const txPeriod = 2.0;
    
    // Vevő oldali változók:
    let ringBuffer = [];   // itt gyűlnek a mikrofonból érkező minták
    let rxStream = null;
    let rxProcessor = null;
    let rxTimer = null;
    
    // Időzítők:
    let txIntervalId = null;
    
    /********** AudioContext **********/
    function ensureAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
    }
    
    /********** Adó oldal: Testjel generálása **********/
    // generateTestSignal: előállít egy 1.5 s hosszú testjelet az alábbi felépítéssel:
    // – 0 ... T_ramp: fade-in Hann ablakos felfutás (0→1)
    // – T_ramp ... T_ramp+T_hold: hold rész; itt a fázis:
    //     • első fele: +1, második fele: -1
    // – T_ramp+T_hold ... T_total: fade-out Hann ablakos lecsengés (1→0)
    // A txPolarity paraméterrel további globális inverzió is alkalmazható: normal = +1, inverted = -1.
    function generateTestSignal(txPolarity) {
      ensureAudioContext();
      const sampleRate = audioContext.sampleRate;
      const totalSamples = Math.floor(T_total * sampleRate);
      const rampSamples = Math.floor(T_ramp * sampleRate);
      const holdSamples = Math.floor(T_hold * sampleRate);
      const fadeSamples = Math.floor(T_fade * sampleRate);
      const buffer = new Float32Array(totalSamples);
      // paraméter: 1 vagy -1
      const globalPolarity = (txPolarity === "normal") ? 1 : -1;
      
      for (let i = 0; i < totalSamples; i++) {
        const t = i / sampleRate;
        let env = 0;
        // Fade-in
        if (t < T_ramp) {
          env = 0.5 * (1 - Math.cos(Math.PI * t / T_ramp));
        }
        // Hold
        else if (t < T_ramp + T_hold) {
          env = 1;
        }
        // Fade-out
        else {
          const t_fade = t - (T_ramp + T_hold);
          env = 0.5 * (1 + Math.cos(Math.PI * t_fade / T_fade));
        }
        // Fázis faktor a hold részre:
        let phaseFactor = 1;
        if (t >= T_ramp && t < T_ramp + T_hold) {
          const t_hold = t - T_ramp;
          // Első fele hold: +1, második fele hold: -1
          phaseFactor = (t_hold < T_hold/2) ? 1 : -1;
        }
        // Egyébként a fázis faktor legyen 1
        // Carrier: sine wave fc frekvencián
        const carrier = Math.sin(2 * Math.PI * fc * t);
        buffer[i] = env * phaseFactor * globalPolarity * carrier;
      }
      return buffer;
    }
    
    // playTestSignal: lejátsza a generált testjelet, majd azonnal egy kis csendet (ha szükséges)
    function playTestSignal(txPolarity) {
      ensureAudioContext();
      const sampleRate = audioContext.sampleRate;
      const testData = generateTestSignal(txPolarity);
      // Nem illeszthetünk külön csendet, mert a testjel már 1.5 s; a txPeriod-ben a csend van
      // Hozzunk létre egy AudioBuffer-t a testData alapján
      const buffer = audioContext.createBuffer(1, testData.length, sampleRate);
      buffer.copyToChannel(testData, 0);
      const source = audioContext.createBufferSource();
      source.buffer = buffer;
      source.connect(audioContext.destination);
      source.start();
      // Frissítsük a canvas-t egyszer (a testjel hullámformája)
      drawWaveform(testData);
      document.getElementById("txStatus").textContent = "Adó: " + new Date().toLocaleTimeString() + " – testjel lejátszva";
      statusElem.textContent = "Adó: testjel lejátszva";
    }
    
    function startTransmitter() {
      ensureAudioContext();
      const txPolarity = document.getElementById("txPolaritySelect").value;
      playTestSignal(txPolarity);
      txIntervalId = setInterval(() => {
        playTestSignal(txPolarity);
      }, txPeriod * 1000);
      document.getElementById("txStatus").textContent = "Adó mód aktív: testjel folyamatos lejátszása...";
      statusElem.textContent = "Adó: mód aktív";
    }
    
    function stopTransmitter() {
      if (txIntervalId) {
        clearInterval(txIntervalId);
        txIntervalId = null;
      }
      document.getElementById("txStatus").textContent = "Adó: leállítva";
      statusElem.textContent = "Adó: leállítva";
    }
    
    /********** Vevő oldal: Detektálás **********/
    // A vevő oldalon a mikrofonból érkező mintákat egy ringBuffer-be gyűjtjük.
    // Ha elég adat érkezik, a checkForTestSignal függvény megkísérli a testjel detektálását a referenciaként
    // használt, "normál" testjellel (saját generált sablon) történő korrelációval.
    // Ha a korreláció erős, akkor a hold részből kiszámoljuk a két fel átlagát:
    // • 0.2–0.6 s: firstHold átlag
    // • 0.6–1.0 s: secondHold átlag
    // Ha az első átlag pozitív és a második negatív → "Normál",
    // ha fordítva → "Inverz".
    function checkForTestSignal() {
      ensureAudioContext();
      const sampleRate = audioContext.sampleRate;
      // Előállítjuk a referenciaként használt "normál" testjelet
      const refSignal = generateTestSignal("normal");
      const L = refSignal.length;
      if (ringBuffer.length < L) return; // nincs elég adat
      // Egyszerű korreláció: csúsztassuk végig a ringBuffer-t, keressük a maximum korrelációt
      let bestCorr = 0;
      let bestIndex = 0;
      const step = 10;
      for (let i = 0; i <= ringBuffer.length - L; i += step) {
        let sum = 0;
        for (let j = 0; j < L; j++) {
          sum += ringBuffer[i + j] * refSignal[j];
        }
        if (Math.abs(sum) > Math.abs(bestCorr)) {
          bestCorr = sum;
          bestIndex = i;
        }
      }
      // Állítsunk be egy küszöböt – ez kísérleti, de pl. 0.4-szerese a refSignal energiájának
      let energy = 0;
      for (let j = 0; j < L; j++) {
        energy += refSignal[j] * refSignal[j];
      }
      const threshold = 0.4 * energy;
      
      const rxResultElem = document.getElementById("rxResult");
      if (Math.abs(bestCorr) < threshold) {
        rxResultElem.textContent = "Eredmény: testjel nem detektálható";
      } else {
        // Ha detektáltuk a testjelet, vesszük ki a hold részt:
        // A hold rész a testjelben 0.2 s-től 1.0 s-ig tart, azaz:
        const startHold = Math.floor(0.2 * sampleRate);
        const midHold = Math.floor(0.6 * sampleRate);
        const endHold = Math.floor(1.0 * sampleRate);
        // A "detektált" testjel szegmens:
        const detected = ringBuffer.slice(bestIndex, bestIndex + L);
        // Első hold fél átlag:
        let sumFirst = 0, countFirst = 0;
        for (let i = startHold; i < midHold; i++) {
          sumFirst += detected[i];
          countFirst++;
        }
        const avgFirst = sumFirst / countFirst;
        // Második hold fél átlag:
        let sumSecond = 0, countSecond = 0;
        for (let i = midHold; i < endHold; i++) {
          sumSecond += detected[i];
          countSecond++;
        }
        const avgSecond = sumSecond / countSecond;
        let result;
        if (avgFirst > 0 && avgSecond < 0) {
          result = "Normál";
        } else if (avgFirst < 0 && avgSecond > 0) {
          result = "Inverz";
        } else {
          result = "Inkonzisztens";
        }
        rxResultElem.textContent = "Eredmény: " + result + " polaritás (corr=" + bestCorr.toFixed(2) + ")";
      }
      // A ringBuffer-t megtartjuk a jobb szinkronizáció érdekében: töröljük az eddigi részt, de megtartjuk az utolsó L mintát
      if (ringBuffer.length > 2 * L) {
        ringBuffer = ringBuffer.slice(ringBuffer.length - L);
      }
    }
    
    function startReceiver() {
      ensureAudioContext();
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(function(stream) {
          rxStream = stream;
          const source = audioContext.createMediaStreamSource(stream);
          rxProcessor = audioContext.createScriptProcessor(2048, 1, 1);
          source.connect(rxProcessor);
          // A destination-re csatlakozás opcionális, de egyes böngészőkben segíthet
          rxProcessor.connect(audioContext.destination);
          rxProcessor.onaudioprocess = function(e) {
            const inputData = e.inputBuffer.getChannelData(0);
            ringBuffer = ringBuffer.concat(Array.from(inputData));
            // Korlátozzuk a ringBuffer hosszát (pl. 5 másodperc adat)
            const maxLength = Math.floor(audioContext.sampleRate * 5);
            if (ringBuffer.length > maxLength) {
              ringBuffer = ringBuffer.slice(ringBuffer.length - maxLength);
            }
            // Ne frissítsük folyamatosan a canvas-t – csak a detektálásnál
          };
          // Indítsuk el a testjel-ellenőrzést például 1 s-enként
          rxTimer = setInterval(checkForTestSignal, 1000);
          statusElem.textContent = "Vevő: mikrofon aktív, figyelem...";
        })
        .catch(function(err) {
          statusElem.textContent = "Vevő: Hiba – mikrofon hozzáférés megtagadva!";
          console.error(err);
        });
    }
    
    function stopReceiver() {
      if (rxProcessor) {
        rxProcessor.disconnect();
        rxProcessor = null;
      }
      if (rxStream) {
        rxStream.getTracks().forEach(track => track.stop());
        rxStream = null;
      }
      if (rxTimer) {
        clearInterval(rxTimer);
        rxTimer = null;
      }
      ringBuffer = [];
      document.getElementById("rxResult").textContent = "Eredmény: leállítva";
      statusElem.textContent = "Vevő: leállítva";
    }
    
    /********** Canvas rajzoló **********/
    function drawWaveform(data) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      const midY = canvas.height / 2;
      const scaleX = canvas.width / data.length;
      const scaleY = canvas.height / 2;
      ctx.moveTo(0, midY);
      for (let i = 0; i < data.length; i++) {
        const x = i * scaleX;
        const y = midY - data[i] * scaleY;
        ctx.lineTo(x, y);
      }
      ctx.strokeStyle = "#0077cc";
      ctx.stroke();
    }
    
    /********** UI vezérlés **********/
    modeSelect.addEventListener("change", function() {
      mode = this.value;
      if (mode === "transmitter") {
        transmitterSection.style.display = "block";
        receiverSection.style.display = "none";
        stopReceiver();
      } else {
        transmitterSection.style.display = "none";
        receiverSection.style.display = "block";
        stopTransmitter();
      }
    });
    
    document.getElementById("txStartBtn").addEventListener("click", function() {
      ensureAudioContext();
      if (audioContext.state === "suspended") audioContext.resume();
      startTransmitter();
    });
    
    document.getElementById("txStopBtn").addEventListener("click", stopTransmitter);
    
    document.getElementById("rxStartBtn").addEventListener("click", function() {
      ensureAudioContext();
      if (audioContext.state === "suspended") audioContext.resume();
      startReceiver();
    });
    
    document.getElementById("rxStopBtn").addEventListener("click", stopReceiver);
    
    // Egy kattintás a dokumentumon feloldja az AudioContext-et (szükséges egyes böngészőkben)
    document.body.addEventListener("click", function() {
      if (audioContext && audioContext.state === "suspended") {
        audioContext.resume();
      }
    });
  </script>
</body>
</html>

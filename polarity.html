<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <title>Peak Detector VU Meter – Paraméterezhető</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f7f7f7;
      text-align: center;
      margin: 20px;
    }
    h1 { color: #333; }
    .section {
      border: 1px solid #ccc;
      background: #eee;
      padding: 10px;
      margin: 10px;
    }
    button, input[type=range] {
      font-size: 1rem;
      margin: 0.5rem;
      padding: 0.3rem 0.8rem;
    }
    #vuCanvas {
      border: 1px solid #ccc;
      background: #fff;
      margin: 20px auto;
      display: block;
    }
    .sliderContainer { margin: 10px; }
  </style>
</head>
<body>
  <h1>Peak Detector VU Meter</h1>
  
  <!-- Vevő (Receiver) rész -->
  <div id="receiverSection" class="section">
    <h2>Vevő (Receiver) – Peak Detector</h2>
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
    <p id="peakDisplay">Current Peak: 0.00</p>
    
    <div class="sliderContainer">
      <label for="decaySlider">Decay Faktor (0.90 - 1.00): <span id="decayVal">0.980</span></label><br>
      <input type="range" id="decaySlider" min="0.90" max="1.00" step="0.001" value="0.980">
    </div>
    <div class="sliderContainer">
      <label for="updateSlider">Frissítési idő (ms): <span id="updateVal">50</span></label><br>
      <input type="range" id="updateSlider" min="20" max="200" step="10" value="50">
    </div>
    
    <!-- A VU meter megjelenítéséhez -->
    <canvas id="vuCanvas" width="300" height="30"></canvas>
  </div>
  
  <script>
    /********** Globális változók **********/
    let audioContext = null;
    let micStream = null;
    let scriptProcessor = null;
    
    // A jelenlegi peak érték (0-1 között)
    let currentPeak = 0;
    
    // Paraméterek, melyek állíthatók a csúszkákkal
    let decayFactor = parseFloat(document.getElementById("decaySlider").value); // pl. 0.980
    let updateIntervalMs = parseInt(document.getElementById("updateSlider").value); // pl. 50 ms
    
    // Timer a peak decay frissítéséhez
    let decayTimerId = null;
    
    // UI elemek
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const peakDisplay = document.getElementById("peakDisplay");
    const vuCanvas = document.getElementById("vuCanvas");
    const vuCtx = vuCanvas.getContext("2d");
    const decaySlider = document.getElementById("decaySlider");
    const decayValLabel = document.getElementById("decayVal");
    const updateSlider = document.getElementById("updateSlider");
    const updateValLabel = document.getElementById("updateVal");
    
    // Frissítjük a csúszka értékeit
    decaySlider.addEventListener("input", function() {
      decayFactor = parseFloat(this.value);
      decayValLabel.textContent = this.value;
    });
    updateSlider.addEventListener("input", function() {
      updateIntervalMs = parseInt(this.value);
      updateValLabel.textContent = this.value;
      // Ha a timer már fut, újraindítjuk az update intervalt
      if (decayTimerId) {
        clearInterval(decayTimerId);
        decayTimerId = setInterval(decayPeak, updateIntervalMs);
      }
    });
    
    /********** AudioContext létrehozása **********/
    function ensureAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
    }
    
    /********** Peak Detector Logika **********/
    // Decay függvény: csökkenti a currentPeak értékét, majd frissíti a VU metert és a numerikus kijelzést
    function decayPeak() {
      // Csak akkor csökkentsük, ha currentPeak > 0
      if (currentPeak > 0) {
        currentPeak *= decayFactor;
        if (currentPeak < 0.001) { // ha nagyon kicsi, állítsuk 0-ra
          currentPeak = 0;
        }
        updateVUMeterDisplay();
      }
    }
    
    // Frissíti a VU meter kijelzését a currentPeak értéke alapján
    function updateVUMeterDisplay() {
      const width = vuCanvas.width;
      const height = vuCanvas.height;
      vuCtx.clearRect(0, 0, width, height);
      // Rajzoljuk a hátteret
      vuCtx.fillStyle = "#ddd";
      vuCtx.fillRect(0, 0, width, height);
      // A currentPeak érték arányában rajzoljuk meg a kitöltött sávot
      const barWidth = Math.min(width, currentPeak * width);
      vuCtx.fillStyle = "#00aa00";
      vuCtx.fillRect(0, 0, barWidth, height);
      // Frissítsük a numerikus kijelzést
      peakDisplay.textContent = "Current Peak: " + currentPeak.toFixed(3);
    }
    
    /********** Mikrofon adatainak feldolgozása **********/
    function startPeakDetection() {
      ensureAudioContext();
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(function(stream) {
          micStream = stream;
          const source = audioContext.createMediaStreamSource(stream);
          // A ScriptProcessorNode segítségével feldolgozzuk a mikrofon adatot
          scriptProcessor = audioContext.createScriptProcessor(2048, 1, 1);
          source.connect(scriptProcessor);
          scriptProcessor.connect(audioContext.destination); // Bizonyos böngészőkben szükséges
          scriptProcessor.onaudioprocess = function(e) {
            const inputData = e.inputBuffer.getChannelData(0);
            // Keressük meg a frame legnagyobb abszolút értékét
            let framePeak = 0;
            for (let i = 0; i < inputData.length; i++) {
              const absVal = Math.abs(inputData[i]);
              if (absVal > framePeak) framePeak = absVal;
            }
            // Ha a framePeak nagyobb, mint a jelenlegi peak, akkor frissítjük
            if (framePeak > currentPeak) {
              currentPeak = framePeak;
              updateVUMeterDisplay();
            }
          };
          // Indítsuk el a decay-t egy időzítővel
          decayTimerId = setInterval(decayPeak, updateIntervalMs);
        })
        .catch(function(err) {
          console.error("Hiba a mikrofon elérésében:", err);
        });
    }
    
    function stopPeakDetection() {
      if (scriptProcessor) {
        scriptProcessor.disconnect();
        scriptProcessor = null;
      }
      if (micStream) {
        micStream.getTracks().forEach(track => track.stop());
        micStream = null;
      }
      if (decayTimerId) {
        clearInterval(decayTimerId);
        decayTimerId = null;
      }
      currentPeak = 0;
      updateVUMeterDisplay();
    }
    
    /********** UI vezérlés **********/
    document.getElementById("startBtn").addEventListener("click", function() {
      ensureAudioContext();
      if (audioContext.state === "suspended") {
        audioContext.resume();
      }
      startPeakDetection();
    });
    
    document.getElementById("stopBtn").addEventListener("click", function() {
      stopPeakDetection();
    });
    
    // Egy kattintás a dokumentumon feloldja az AudioContext-et (szükséges egyes böngészőkben)
    document.body.addEventListener("click", function() {
      if (audioContext && audioContext.state === "suspended") {
        audioContext.resume();
      }
    });
  </script>
</body>
</html>

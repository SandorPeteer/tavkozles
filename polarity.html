<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <title>Chirp alapú Polaritás Mérő</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f7f7f7;
      text-align: center;
      margin: 20px;
    }
    h1 { color: #333; }
    .section {
      border: 1px solid #ccc;
      background: #eee;
      padding: 10px;
      margin: 10px;
    }
    button, select {
      font-size: 1rem;
      margin: 0.5rem;
      padding: 0.3rem 0.8rem;
    }
    #canvas {
      border: 1px solid #ccc;
      background: #fff;
      margin: 20px auto;
      display: block;
    }
  </style>
</head>
<body>
  <h1>Chirp alapú Polaritás Mérő</h1>
  <!-- Üzemmód választás -->
  <div>
    <label for="modeSelect">Üzemmód:</label>
    <select id="modeSelect">
      <option value="transmitter">Adó (Transmitter)</option>
      <option value="receiver">Vevő (Receiver)</option>
    </select>
  </div>
  
  <!-- Adó rész -->
  <div id="transmitterSection" class="section">
    <h2>Adó (Transmitter)</h2>
    <label for="txPolaritySelect">Chirp polaritása:</label>
    <select id="txPolaritySelect">
      <option value="normal">Normál</option>
      <option value="inverted">Inverz</option>
    </select>
    <br>
    <button id="txStartBtn">Adó Start</button>
    <button id="txStopBtn">Adó Stop</button>
    <p id="txStatus">Adó: várakozás...</p>
  </div>
  
  <!-- Vevő rész -->
  <div id="receiverSection" class="section" style="display: none;">
    <h2>Vevő (Receiver)</h2>
    <button id="rxStartBtn">Vevő Start</button>
    <button id="rxStopBtn">Vevő Stop</button>
    <p id="rxResult">Eredmény: várakozás...</p>
  </div>
  
  <canvas id="canvas" width="800" height="200"></canvas>
  <p id="status">Állapot: várakozás...</p>
  
  <script>
    /********** Globális változók **********/
    let audioContext = null;
    let mode = "transmitter"; // alapértelmezett
    const modeSelect = document.getElementById("modeSelect");
    const transmitterSection = document.getElementById("transmitterSection");
    const receiverSection = document.getElementById("receiverSection");
    const statusElem = document.getElementById("status");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    
    // Chirp paraméterek (Adó):
    const Tchirp = 0.5;      // chirp időtartam (0.5 s)
    const f0 = 100;          // kezdő frekvencia (Hz)
    const f1 = 1000;         // végfrekvencia (Hz)
    const chirpGap = 0.5;    // csend idő (0.5 s) a chirp után → teljes periódus: 1 s
    
    // Vevő oldali paraméterek:
    let ringBuffer = [];     // mikrofonból érkező minták tárolása
    let rxStream = null;
    let rxProcessor = null;
    let rxTimer = null;
    
    // Időzítők:
    let txIntervalId = null;
    
    // Downsampling faktor a vevő korrelációhoz (pl. 10-szeres downsample)
    const DS_FACTOR = 10;
    
    /********** AudioContext létrehozása **********/
    function ensureAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
    }
    
    /********** Adó oldal: Chirp generálása **********/
    // Generál egy lineáris chirp-et a Tchirp időtartamon, f0-tól f1-ig
    // Alkalmazunk egy sima fade-in/fade-out Hann ablakot
    function generateChirp(txPolarity) {
      ensureAudioContext();
      const sampleRate = audioContext.sampleRate;
      const totalSamples = Math.floor(Tchirp * sampleRate);
      const chirp = new Float32Array(totalSamples);
      // Számoljuk ki a frekvenciaváltozás mértékét
      const k = (f1 - f0) / Tchirp;
      // txPolarity: "normal" => faktor = 1, "inverted" => faktor = -1
      const polarityFactor = (txPolarity === "normal") ? 1 : -1;
      for (let i = 0; i < totalSamples; i++) {
        const t = i / sampleRate;
        // Lineáris chirp: f(t) = f0 + k*t; fázis = 2π (f0*t + 0.5*k*t^2)
        const phase = 2 * Math.PI * (f0 * t + 0.5 * k * t * t);
        let sample = Math.sin(phase);
        // Alkalmazzuk a polaritást
        sample *= polarityFactor;
        // Alkalmazzunk Hann ablakot (fade-in és fade-out)
        const windowVal = 0.5 * (1 - Math.cos(2 * Math.PI * i / (totalSamples - 1)));
        chirp[i] = sample * windowVal;
      }
      return chirp;
    }
    
    // Lejátszás: A chirp-et lejátszuk, majd a chirp hosszának megfelelő csendet adunk hozzá
    function playChirp(txPolarity) {
      ensureAudioContext();
      const sampleRate = audioContext.sampleRate;
      const chirpData = generateChirp(txPolarity);
      const silenceSamples = Math.floor(chirpGap * sampleRate);
      // Összefűzzük a chirp-et és a csendet
      const composite = new Float32Array(chirpData.length + silenceSamples);
      composite.set(chirpData, 0);
      // A csend rész marad 0
      const buffer = audioContext.createBuffer(1, composite.length, sampleRate);
      buffer.copyToChannel(composite, 0);
      const source = audioContext.createBufferSource();
      source.buffer = buffer;
      source.connect(audioContext.destination);
      source.start();
      // Kirajzoljuk a chirp hullámformáját a canvas-ra
      drawWaveform(chirpData);
      document.getElementById("txStatus").textContent = "Adó: " + new Date().toLocaleTimeString() + " – chirp lejátszva";
      statusElem.textContent = "Adó: chirp lejátszva";
    }
    
    function startTransmitter() {
      ensureAudioContext();
      const txPolarity = document.getElementById("txPolaritySelect").value;
      // Azonnali lejátszás:
      playChirp(txPolarity);
      // Ismétlődő lejátszás a teljes periódus után (Tchirp + chirpGap)
      txIntervalId = setInterval(() => {
        playChirp(txPolarity);
      }, (Tchirp + chirpGap) * 1000);
      document.getElementById("txStatus").textContent = "Adó mód aktív: chirp folyamatos lejátszása...";
      statusElem.textContent = "Adó: mód aktív";
    }
    
    function stopTransmitter() {
      if (txIntervalId) {
        clearInterval(txIntervalId);
        txIntervalId = null;
      }
      document.getElementById("txStatus").textContent = "Adó: leállítva";
      statusElem.textContent = "Adó: leállítva";
    }
    
    /********** Vevő oldal: Downsampling és korreláció **********/
    // Downsample egy tömböt a megadott faktorral
    function downsampleBuffer(buffer, factor) {
      const len = Math.floor(buffer.length / factor);
      const down = new Float32Array(len);
      for (let i = 0; i < len; i++) {
        down[i] = buffer[i * factor];
      }
      return down;
    }
    
    // Egyszerű korreláció: a "signal" és a "template" dot terméke, csúsztatva a signal-ben
    function crossCorrelate(signal, template) {
      let bestCorr = 0;
      let bestIndex = 0;
      for (let i = 0; i <= signal.length - template.length; i++) {
        let sum = 0;
        for (let j = 0; j < template.length; j++) {
          sum += signal[i + j] * template[j];
        }
        if (Math.abs(sum) > Math.abs(bestCorr)) {
          bestCorr = sum;
          bestIndex = i;
        }
      }
      return bestCorr;
    }
    
    // A vevő oldalon a ringBuffer-ben tárolt adatokból ellenőrizzük a chirp-et
    function checkForChirp() {
      ensureAudioContext();
      const sampleRate = audioContext.sampleRate;
      // Ha nincs elég adat, ne csináljunk semmit
      if (ringBuffer.length < sampleRate * (Tchirp + chirpGap) * 0.5) return;
      
      // Downsample-eljük a ringBuffer-t a DS_FACTOR segítségével
      const dsBuffer = downsampleBuffer(ringBuffer, DS_FACTOR);
      // Generáljuk a referenciaként használt "normál" chirp sablont, majd downsample-eljük
      const refChirp = generateChirp("normal");
      const dsRef = downsampleBuffer(refChirp, DS_FACTOR);
      
      // Végezünk egy csúszókorrelációt a downsample-elt adatokon
      const corr = crossCorrelate(dsBuffer, dsRef);
      
      // Állítsuk be egy küszöbértéket (kísérleti)
      const threshold = 0.3 * dsRef.length;
      
      let rxResultElem = document.getElementById("rxResult");
      if (Math.abs(corr) < threshold) {
        rxResultElem.textContent = "Eredmény: nem detektálható tiszta chirp";
      } else {
        // Ha a korreláció pozitív, akkor a bejövő chirp fázisa megegyezik a referenciával (Normál)
        // Ha negatív, akkor ellentétes fázisú (Inverz)
        const result = (corr > 0) ? "Normál" : "Inverz";
        rxResultElem.textContent = "Eredmény: " + result + " polaritás (korreláció: " + corr.toFixed(2) + ")";
      }
      
      // Az erőforrások optimalizálása: megtartjuk az utolsó néhány másodperc adatait
      const L = Math.floor(sampleRate * (Tchirp + chirpGap));
      if (ringBuffer.length > 2 * L) {
        ringBuffer = ringBuffer.slice(ringBuffer.length - L);
      }
    }
    
    function startReceiver() {
      ensureAudioContext();
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(function(stream) {
          rxStream = stream;
          const source = audioContext.createMediaStreamSource(stream);
          rxProcessor = audioContext.createScriptProcessor(2048, 1, 1);
          source.connect(rxProcessor);
          // A destination-re csatlakozás opcionális, de segíthet néhány böngészőben
          rxProcessor.connect(audioContext.destination);
          rxProcessor.onaudioprocess = function(e) {
            const inputData = e.inputBuffer.getChannelData(0);
            // Gyűjtsük a mintákat a ringBuffer-be
            ringBuffer = ringBuffer.concat(Array.from(inputData));
            // Ne próbáljuk folyamatosan frissíteni a canvas-t – csak a kódellenőrzésnél
          };
          // Időzítjük a chirpellenőrzést (pl. 1 s-enként)
          rxTimer = setInterval(checkForChirp, 1000);
          statusElem.textContent = "Vevő: mikrofon aktív, figyelem...";
        })
        .catch(function(err) {
          statusElem.textContent = "Vevő: Hiba – mikrofonhoz való hozzáférés megtagadva!";
          console.error(err);
        });
    }
    
    function stopReceiver() {
      if (rxProcessor) {
        rxProcessor.disconnect();
        rxProcessor = null;
      }
      if (rxStream) {
        rxStream.getTracks().forEach(track => track.stop());
        rxStream = null;
      }
      if (rxTimer) {
        clearInterval(rxTimer);
        rxTimer = null;
      }
      ringBuffer = [];
      document.getElementById("rxResult").textContent = "Eredmény: leállítva";
      statusElem.textContent = "Vevő: leállítva";
    }
    
    /********** Canvas rajzoló **********/
    function drawWaveform(data) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      const midY = canvas.height / 2;
      const scaleX = canvas.width / data.length;
      const scaleY = canvas.height / 2;
      ctx.moveTo(0, midY);
      for (let i = 0; i < data.length; i++) {
        const x = i * scaleX;
        const y = midY - data[i] * scaleY;
        ctx.lineTo(x, y);
      }
      ctx.strokeStyle = "#0077cc";
      ctx.stroke();
    }
    
    /********** UI vezérlés **********/
    modeSelect.addEventListener("change", function() {
      mode = this.value;
      if (mode === "transmitter") {
        transmitterSection.style.display = "block";
        receiverSection.style.display = "none";
        stopReceiver();
      } else {
        transmitterSection.style.display = "none";
        receiverSection.style.display = "block";
        stopTransmitter();
      }
    });
    
    document.getElementById("txStartBtn").addEventListener("click", function() {
      ensureAudioContext();
      if (audioContext.state === "suspended") audioContext.resume();
      startTransmitter();
    });
    
    document.getElementById("txStopBtn").addEventListener("click", stopTransmitter);
    
    document.getElementById("rxStartBtn").addEventListener("click", function() {
      ensureAudioContext();
      if (audioContext.state === "suspended") audioContext.resume();
      startReceiver();
    });
    
    document.getElementById("rxStopBtn").addEventListener("click", stopReceiver);
    
    // Egy kattintás a dokumentumon feloldja az AudioContext-et (néhány böngészőben szükséges)
    document.body.addEventListener("click", function() {
      if (audioContext && audioContext.state === "suspended") {
        audioContext.resume();
      }
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <title>Egyszerű Testimpulzus Polaritás Mérés</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      margin: 20px;
      background: #f7f7f7;
    }
    h1 {
      color: #333;
    }
    #controls {
      margin: 10px;
    }
    .section {
      border: 1px solid #ccc;
      padding: 10px;
      margin: 10px;
    }
    #waveformCanvas {
      border: 1px solid #ccc;
      background: #fff;
      margin: 20px auto;
      display: block;
    }
    button, select {
      font-size: 1rem;
      margin: 0.5rem;
      padding: 0.3rem 0.8rem;
    }
  </style>
</head>
<body>
  <h1>Testimpulzus Polaritás Mérés</h1>
  <div id="controls">
    <label for="modeSelect">Üzemmód:</label>
    <select id="modeSelect">
      <option value="transmitter">Adó (Transmitter)</option>
      <option value="receiver">Vevő (Receiver)</option>
    </select>
  </div>

  <!-- Adó (Transmitter) szekció -->
  <div id="transmitter" class="section">
    <h2>Adó (Transmitter)</h2>
    <label for="polaritySelect">Tesztimpulzus polaritás:</label>
    <select id="polaritySelect">
      <option value="normal">Normál (pozitív csúcs)</option>
      <option value="inverted">Inverz (negatív csúcs)</option>
    </select>
    <br>
    <button id="txStartBtn">Adó Start</button>
    <button id="txStopBtn">Adó Stop</button>
  </div>

  <!-- Vevő (Receiver) szekció -->
  <div id="receiver" class="section" style="display: none;">
    <h2>Vevő (Receiver)</h2>
    <button id="rxStartBtn">Vevő Start</button>
    <button id="rxStopBtn">Vevő Stop</button>
  </div>

  <p id="status">Állapot: Várakozás...</p>
  <canvas id="waveformCanvas" width="800" height="200"></canvas>

  <script>
    // Globális változók
    let audioContext = null;
    let txIntervalId = null;
    let rxStream = null;
    let rxProcessor = null;
    let lastDetectionTime = 0;

    // Paraméterek
    const testPulseDuration = 0.2;   // 200 ms
    const testPulseFrequency = 500;  // 500 Hz
    const pulseInterval = 2000;      // 2 s időköz
    const detectionThreshold = 0.3;  // Küszöbérték a vevő oldalán
    const detectionCooldown = 1000;  // 1 s védőidő

    // UI elemek
    const modeSelect = document.getElementById("modeSelect");
    const transmitterDiv = document.getElementById("transmitter");
    const receiverDiv = document.getElementById("receiver");
    const statusElem = document.getElementById("status");
    const canvas = document.getElementById("waveformCanvas");
    const ctx = canvas.getContext("2d");

    // --- Általános függvény: AudioContext indítása ---
    function ensureAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    // --- Adó oldal ---
    // Tesztimpulzus generálása: Hann ablakos sine wave, a polaritás választásának megfelelően
    function generateTestPulse(duration, frequency, polarity) {
      ensureAudioContext();
      const sampleRate = audioContext.sampleRate;
      const length = Math.floor(duration * sampleRate);
      const buffer = new Float32Array(length);
      for (let i = 0; i < length; i++) {
        const t = i / sampleRate;
        // Hann ablak
        const envelope = 0.5 * (1 - Math.cos(2 * Math.PI * i / (length - 1)));
        let sample = Math.sin(2 * Math.PI * frequency * t);
        if (polarity === 'inverted') {
          sample = -sample;
        }
        buffer[i] = envelope * sample;
      }
      return buffer;
    }

    // Lejátszás: létrehoz egy AudioBuffer-t a generált tesztimpulzussal, kirajzolja a hullámformát, majd lejátsza
    function playTestPulse() {
      ensureAudioContext();
      const polarity = document.getElementById("polaritySelect").value;
      const pulseData = generateTestPulse(testPulseDuration, testPulseFrequency, polarity);
      drawWaveform(pulseData);
      const buffer = audioContext.createBuffer(1, pulseData.length, audioContext.sampleRate);
      buffer.copyToChannel(pulseData, 0);
      const source = audioContext.createBufferSource();
      source.buffer = buffer;
      source.connect(audioContext.destination);
      source.start();
      statusElem.textContent = "Adó: " + new Date().toLocaleTimeString() + " – Tesztimpulzus lejátszva";
    }

    function startTransmitter() {
      ensureAudioContext();
      playTestPulse();
      txIntervalId = setInterval(playTestPulse, pulseInterval);
      statusElem.textContent = "Adó: Mód aktív, tesztimpulzusok ismétlődnek.";
    }

    function stopTransmitter() {
      if (txIntervalId) {
        clearInterval(txIntervalId);
        txIntervalId = null;
        statusElem.textContent = "Adó: Leállítva.";
      }
    }

    // --- Vevő oldal ---
    // Mikrofon adatainak feldolgozása: ha a kapott jelben találunk olyan részt, ahol a minta abszolút értéke meghaladja a küszöböt,
    // kiszámoljuk egy 50 ms-es ablakban az átlagot, és ennek alapján határozzuk meg a polaritást.
    function detectPulse(data) {
      const now = Date.now();
      if (now - lastDetectionTime < detectionCooldown) return;
      let peakIndex = -1;
      let peakValue = 0;
      for (let i = 0; i < data.length; i++) {
        const absVal = Math.abs(data[i]);
        if (absVal > detectionThreshold && absVal > peakValue) {
          peakValue = absVal;
          peakIndex = i;
        }
      }
      if (peakIndex >= 0) {
        const sampleRate = audioContext.sampleRate;
        const windowSize = Math.floor(0.05 * sampleRate);
        let start = Math.max(0, peakIndex - Math.floor(windowSize / 2));
        let end = Math.min(data.length, peakIndex + Math.floor(windowSize / 2));
        let sum = 0, count = 0;
        for (let i = start; i < end; i++) {
          sum += data[i];
          count++;
        }
        const avg = sum / count;
        const polarityDetected = avg > 0 ? "Normál" : "Inverz";
        statusElem.textContent = "Vevő: " + new Date().toLocaleTimeString() + " – Tesztimpulzus detektálva, polaritás: " + polarityDetected;
        lastDetectionTime = now;
      }
    }

    // A kapott adatsor kirajzolása a canvas-ra
    function drawWaveform(data) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      const midY = canvas.height / 2;
      const scaleX = canvas.width / data.length;
      const scaleY = canvas.height / 2;
      ctx.moveTo(0, midY);
      for (let i = 0; i < data.length; i++) {
        const x = i * scaleX;
        const y = midY - data[i] * scaleY;
        ctx.lineTo(x, y);
      }
      ctx.strokeStyle = "#0077cc";
      ctx.stroke();
    }

    function startReceiver() {
      ensureAudioContext();
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(function(stream) {
          rxStream = stream;
          const source = audioContext.createMediaStreamSource(stream);
          rxProcessor = audioContext.createScriptProcessor(2048, 1, 1);
          source.connect(rxProcessor);
          rxProcessor.connect(audioContext.destination); // szükséges egyes böngészőkben
          rxProcessor.onaudioprocess = function(e) {
            const inputData = e.inputBuffer.getChannelData(0);
            detectPulse(inputData);
            // opcionálisan kirajzoljuk az aktuális bejövő adatot
            drawWaveform(inputData);
          };
          statusElem.textContent = "Vevő: Mikrofon aktív, figyelem...";
        })
        .catch(function(err) {
          statusElem.textContent = "Vevő: Hiba – mikrofonhoz való hozzáférés megtagadva!";
          console.error(err);
        });
    }

    function stopReceiver() {
      if (rxProcessor) {
        rxProcessor.disconnect();
        rxProcessor = null;
      }
      if (rxStream) {
        rxStream.getTracks().forEach(track => track.stop());
        rxStream = null;
      }
      statusElem.textContent = "Vevő: Leállítva.";
    }

    // --- UI vezérlés ---
    modeSelect.addEventListener("change", function() {
      if (this.value === "transmitter") {
        transmitterDiv.style.display = "block";
        receiverDiv.style.display = "none";
        stopReceiver();
      } else {
        transmitterDiv.style.display = "none";
        receiverDiv.style.display = "block";
        stopTransmitter();
      }
    });

    document.getElementById("txStartBtn").addEventListener("click", startTransmitter);
    document.getElementById("txStopBtn").addEventListener("click", stopTransmitter);
    document.getElementById("rxStartBtn").addEventListener("click", startReceiver);
    document.getElementById("rxStopBtn").addEventListener("click", stopReceiver);

    // Bizonyos böngészőkben a kattintás szükséges az AudioContext feloldásához
    document.body.addEventListener("click", function() {
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
      }
    });
  </script>
</body>
</html>
